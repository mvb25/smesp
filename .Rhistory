# Categorical variable, level 2
grp2_range <- df %>%
filter(x_cat == group_data$x_cat[2]) %>%
summarise(min = 0.95*min(x_cont), max = 1.05*max(x_cont))
grp2 <- data.frame(x_cont = seq(grp2_range$min, grp2_range$max,
length.out = max(1024, group_data$nr_new[2])),
heterosc = seq(1, attributes(df)$het_cont1,
length.out = max(1024, group_data$nr_new[2]))) %>%
mutate(sdx = heterosc * (attributes(df)$error_cont1 * group_data$grp_err[2]) / mean(heterosc)) %>%
slice_sample(n = group_data$nr_new[2], replace=T) %>% select(-heterosc) %>%
mutate(x_cat = group_data$x_cat[2])
# Categorical variable, join two levels
xy_data <- bind_rows(grp1, grp2)
} else if(xdistr == "as data") {
# Categorical variable, level 1
# figure out how to use map() here!
x_dens_distr <- df %>%
filter(x_cat == group_data$x_cat[1])
x_dens_distr = density(x_dens_distr$x_cont,
n = max(1024, group_data$nr_new[1]),
from = 0.95*min(x_dens_distr$x_cont), to = 1.05*max(x_dens_distr$x_cont))
grp1 <- data.frame(x_cont = x_dens_distr$x,
heterosc = seq(1, attributes(df)$het_cont1,
length.out = max(1024, group_data$nr_new[1]))) %>%
mutate(sdx = heterosc * (attributes(df)$error_cont1 * group_data$grp_err[1]) / mean(heterosc)) %>%
slice_sample(n = group_data$nr_new[1], weight_by = x_dens_distr$y, replace=T) %>% select(-heterosc) %>%
mutate(x_cat = group_data$x_cat[1])
# Categorical variable, level 2
x_dens_distr <- df %>%
filter(x_cat == group_data$x_cat[2])
x_dens_distr = density(x_dens_distr$x_cont,
n = max(1024, group_data$nr_new[2]),
from = 0.95*min(x_dens_distr$x_cont), to = 1.05*max(x_dens_distr$x_cont))
grp2 <- data.frame(x_cont = x_dens_distr$x,
heterosc = seq(1, attributes(df)$het_cont1,
length.out = max(1024, group_data$nr_new[2]))) %>%
mutate(sdx = heterosc * (attributes(df)$error_cont1 * group_data$grp_err[2]) / mean(heterosc)) %>%
slice_sample(n = group_data$nr_new[2], weight_by = x_dens_distr$y, replace=T) %>% select(-heterosc) %>%
mutate(x_cat = group_data$x_cat[2])
# Categorical variable, join two levels
xy_data <- bind_rows(grp1, grp2)
}
# When null hypothesis: regression statistics of the model fitted on original
# data with categorical variable but no interaction (i.e., no difference in intercept)
if(attributes(df)$procedure == "H0"){
lm.tmp <- lm(y_obs ~ x_cont, data = df)
} else {
# When confidence interval: regression statistics of the model fitted on
# original data with the categorical variable
lm.tmp  <- lm(y_obs ~ x_cat*x_cont, data = df)}
simdat[[i]] <- xy_data %>%
mutate(y_pop =  predict(lm.tmp, newdata = xy_data)) %>%
rowwise() %>%
mutate(sim_y = y_pop + rnorm(1, 0, sdx)) %>%
ungroup() %>%
select(x_cont, x_cat, sim_y)
}
# fitting a regression model on all data frames
simdat <-  simdat %>% map(~ lm(sim_y ~ x_cat + x_cont, data = .))
# Extracting regression statistics
cat_var_levels <- df %>%
distinct(x_cat) %>%
pull(x_cat)
tmp1 <- simdat %>%
map_df(broom::tidy, .id = "id") %>%
rename(replicate = id, p_value= p.value, se = std.error) %>%
mutate(replicate = as.integer(replicate)) %>%
mutate(term = rep(c(str_c("intercept ", cat_var_levels[1]),
"intercept difference",
str_c("slope")),
reps)) %>%
na.omit()
# Extracting R2 statistics
tmp1 <- simdat %>%
map_df(broom::glance, .id = "id") %>%
mutate(replicate = as.integer(id),
term = "R_adj",
estimate = adj.r.squared,
se = NA,
statistic = NA,
p_value = NA) %>%
dplyr::select(replicate, term, estimate, se, statistic, p_value) %>%
bind_rows(tmp1,.)
attr(tmp1, "model_specifications") <- attributes(df)
attr(tmp1, "resampling_specifications") <- list(reps        = reps,
xdistr     = xdistr,
sample_size = sample_size)
if(attributes(df)$procedure == "H0"){
regr_model <- lm(y_obs ~ x_cat*x_cont, data = df)
attr(tmp1, "test_stat") <- unname(coefficients(regr_model)[2])
} else if(attributes(df)$procedure == "CI"){
attr(tmp1, "test_stat") <- 0
}
attr(tmp1, "regr_model_original_data") <- list(tidy_output = broom::tidy(regr_model),
glance_output = broom::glance(regr_model))
return(tmp1)
#---difference between means---------------------------------------------
} else if(attributes(df)$test == "diff means"){
# original data
df <- df %>%
rename(x_obs    = attributes(.)$predictor_variable,
y_obs    = attributes(.)$response_variable)
# get the means of the levels of the categorical variable and the difference
# between these means
model_stats <- df %>%
group_by(x_obs) %>%
summarise(means = mean(y_obs)) %>%
ungroup() %>%
pivot_wider(names_from = x_obs, values_from = means) %>%
mutate(diff_means= .[[1,1]]-.[[1,2]])
# Get the overall mean plus the mean of the residuals (difference between
# group mean and observed values).
model_stats <- df %>%
group_by(x_obs) %>%
# the residuals are calculated as the difference between observed y and
# the group mean of the observed Y
mutate(residual  = y_obs - mean(y_obs)) %>%
# the following two lines mean that we calculate a single sd of the errors
# (observed - mean), i.e., we assume the same error term across groups. That
# might not be true (it is not true for the example data!). If you want to
# use the observed difference in error term, use 'het_cat', based on
# values calculated prior to using this function.
ungroup() %>%
mutate(sd_resid = sd(residual)) %>%
summarise(mean_y_obs = mean(y_obs),
sd_resid = mean(sd_resid)) %>%
# multiply the error term with user-provided factor
bind_cols(model_stats, .)
# Define the size of the sample
if(length(sample_size) == 1){
if(sample_size == "as data"){
nr_samples <- df %>% group_by(x_obs) %>% summarise(nr = n())
} else {
nr_samples <- data.frame(nr = c(sample_size, sample_size))
}
} else if(length(sample_size) == 2){
nr_samples <- data.frame(nr = sample_size)
}
# Calculate the difference between group sds of residuals and that of the
# overall mean
group_sds <- df %>%
group_by(x_obs) %>%
mutate(means = mean(y_obs),
resid = mean(y_obs)-y_obs) %>%
summarise(mean = mean(means),
sd_resid = sd(resid)) %>%
mutate(mf_grp = sd_resid/model_stats$sd_resid[1])
# extract the error_cat values from the attributes of the original data
if(attributes(df)$error_cat == "as data"){
mf <- c(group_sds$mf_grp[1], group_sds$mf_grp[2])
} else{
mf <- c(attributes(df)$error_cat)
}
outcome <- data.frame(t_value = numeric(reps), p_value = numeric(reps), diff_means = numeric(reps))
for(i in 1:reps){
# Get a random sample
if(attributes(df)$procedure == "CI"){
# sample error term and add group means
grp1 = purrr::modify(rnorm(nr_samples$nr[1],
0, mf[1]*model_stats$sd_resid),
~ .x + model_stats[[1]])
grp2 = purrr::modify(rnorm(nr_samples$nr[2],
0, mf[2]*model_stats$sd_resid),
~ .x + model_stats[[2]])
} else if(attributes(df)$procedure == "H0"){
# sample error term and add mean_y_obs
grp1 = purrr::modify(rnorm(nr_samples$nr[1],
0, mf[1]*model_stats$sd_resid),
~ .x + model_stats$mean_y_obs)
grp2 = purrr::modify(rnorm(nr_samples$nr[2],
0, mf[2]*model_stats$sd_resid),
~ .x + model_stats$mean_y_obs)
}
if(mf[1] == mf[2]){
tmp1 <- t.test(grp1, grp2, var.equal=TRUE)
} else{
tmp1 <- t.test(grp1, grp2, var.equal=FALSE)
}
outcome[i,1] <- tmp1[[1]]
outcome[i,2] <- tmp1[[3]]
outcome[i,3] <- tmp1[[5]][1]-tmp1[[5]][2]
}
# Adding attributes to outcome
attr(outcome, "model_specifications") <- attributes(df)
attr(outcome, "resampling_specifications") <- list(reps = reps,
sample_size = sample_size)
if(attributes(df)$procedure == "H0"){
attr(outcome, "test_stat") <- model_stats$diff_means[1]
} else if(attributes(df)$procedure == "CI"){
attr(outcome, "test_stat") <- 0
}
return(outcome)
#---difference between sample proportions---------------------------------------------
} else if(attributes(df)$test == "diff props"){
# original data
df <- df %>%
rename(x_obs    = attributes(.)$predictor_variable,
y_obs    = attributes(.)$response_variable)
# get the proportions of success for both groups separately and overall
proportion_success <- df %>%
group_by(x_obs) %>%
mutate(nr_samples = n()) %>%
# Keep only the successes
filter(y_obs == attributes(df)$success) %>%
# Successes as proportion of total number (per group)
group_by(x_obs, nr_samples) %>%
summarise(prop_grp = n() / mean(nr_samples)) %>%
# code within mutate yields a single value (overall proportion of success)
# and the column with new variable is thus 'filled' with this value
mutate(
(df %>%
mutate(nr_samples = n()) %>%
filter(y_obs == attributes(df)$success) %>%
summarise(prop_all = n() / mean(nr_samples))
)
)
# Define the size of the sample
if(length(sample_size) == 1){
if(sample_size == "as data"){
proportion_success$nr_samples <- proportion_success$nr_samples
} else {
proportion_success$nr_samples <- data.frame(nr = c(sample_size, sample_size))
}
} else if(length(sample_size) == 2){
proportion_success$nr_samples <- c(sample_size)
}
# Get a random sample
outcome <- data.frame(replicate = seq(1:reps),
group1 = numeric(reps),
group2 = numeric(reps))
if(attributes(df)$procedure == "CI"){
for(i in 1:reps){
outcome[i, c(2,3)] <-
proportion_success %>%
mutate(new_prop =
list(sample(x = unique(df$y_obs),
size = nr_samples,
replace = TRUE,
prob = c(prop_grp,
1-prop_grp)))) %>%
unnest(cols = c(new_prop)) %>%
filter(new_prop == attributes(df)$success) %>%
group_by(x_obs) %>%
summarise(prop = n()/mean(nr_samples)) %>%
pivot_wider(names_from = x_obs, values_from = prop)
}
} else if(attributes(df)$procedure == "H0"){
for(i in 1:reps){
outcome[i, c(2,3)] <-
proportion_success %>%
mutate(new_prop =
list(sample(x = unique(df$y_obs),
size = nr_samples,
replace = TRUE,
prob = c(prop_all,
1-prop_all)))) %>%
unnest(cols = c(new_prop)) %>%
filter(new_prop == attributes(df)$success) %>%
group_by(x_obs) %>%
summarise(prop = n()/mean(nr_samples)) %>%
pivot_wider(names_from = x_obs, values_from = prop)
}
}
outcome %<>%
mutate(group_diff = group1-group2)
# Adding attributes to outcome
attr(outcome, "model_specifications") <- attributes(df)
attr(outcome, "resampling_specifications") <- list(reps = reps,
sample_size = sample_size)
if(attributes(df)$procedure == "H0"){
attr(outcome, "test_stat") <- proportion_success$prop_grp[1]-proportion_success$prop_grp[2]
} else if(attributes(df)$procedure == "CI"){
attr(outcome, "test_stat") <- 0
}
return(outcome)
#---Chi-square---------------------------------------------
} else if(attributes(df)$test == "Chi-sqr"){
# original data
df <- df %>%
rename(x_cat1    = attributes(.)$categorical_variable_1,
x_cat2    = attributes(.)$categorical_variable_2,
y_obs     = attributes(.)$response_variable)
# get Chi-square
obs_chi_sqr <-df %>% tabyl(y_obs, x_cat1) %>%
chisq.test() %>% .$statistic
# Define the size of the sample
if(length(sample_size) == 1){
if(sample_size == "as data"){
cat1_info <- df %>%
group_by(x_cat1) %>%
summarise(nr_obs = n()) %>%
ungroup()
} else {
nr_levels <- df %>% distinct(x_cat1) %>% nrow()
cat1_info  <-
data.frame(x_cat1 = sort(unique(df$x_cat1)),
nr_obs = rep(sample_size, nr_levels))
}
} else {
cat1_info <-
data.frame(x_cat1 = sort(unique(df$x_cat1)),
nr_obs = sample_size)
}
# Observed probability per categorical level
cat1_info <- df %>%
group_by(x_cat1,y_obs) %>%
summarise(probs = n()) %>%
group_by(x_cat1) %>%
mutate(probs = probs/sum(probs)) %>%
pivot_wider(names_from = y_obs, values_from = probs) %>%
left_join(cat1_info) %>%
ungroup()
# Null hypothesis probabilities per categorical level
probs_overall <- df %>%
group_by(y_obs) %>%
summarise(probs = n()) %>%
ungroup() %>%
mutate(probs = probs / sum(probs)) %>%
pivot_wider(names_from = y_obs, values_from = probs)
# Get a random sample
outcome <- data.frame(replicate = seq(1:reps),
chi_sqr = numeric(reps))
cat_levels <- sort(unique(df$y_obs))
if(attributes(df)$procedure == "CI"){
for(i in 1:reps){
outcome[i, c(2)] <-
cat1_info %>%
group_split(x_cat1) %>%
map_dfr( ~ data.frame(
category = .$x_cat1,
y_sim  = sample(x = cat_levels,
size = cat1_info$nr_obs,
replace = TRUE,
prob = .[cat_levels]))) %>%
tabyl(y_sim, category) %>%
chisq.test() %>% .$statistic
}
} else if(attributes(df)$procedure == "H0"){
for(i in 1:reps){
outcome[i, c(2)] <-
cat1_info %>%
group_split(x_cat1) %>%
map_dfr( ~ data.frame(
category = .$x_cat1,
y_sim  = sample(x = cat_levels,
size = cat1_info$nr_obs,
replace = TRUE,
prob = as.vector(as.matrix(probs_overall))))) %>%
tabyl(y_sim, category) %>%
chisq.test() %>% .$statistic
}
}
# Adding attributes to outcome
attr(outcome, "model_specifications") <- attributes(df)
attr(outcome, "resampling_specifications") <- list(reps = reps,
sample_size = sample_size)
if(attributes(df)$procedure == "H0"){
attr(outcome, "test_stat") <- unname(obs_chi_sqr)
} else if(attributes(df)$procedure == "CI"){
attr(outcome, "test_stat") <- 0
}
return(outcome)
}
}
plot_distribution <- function(
df,
ref_val = "none"){
# Select data with only selected test statistic
if(attributes(df)$model_specifications$test == "slope"){
dat = df %>%
filter(term == "slope")
} else if(attributes(df)$model_specifications$test == "diff slopes") {
dat = df %>%
filter(term == "slope difference")
} else if(attributes(df)$model_specifications$test == "diff intercepts") {
dat = df %>%
filter(term == "intercept difference")
} else if(attributes(df)$model_specifications$test == "diff means") {
dat = df %>%
select(estimate = 3)
} else if(attributes(df)$model_specifications$test == "diff props") {
dat = df %>%
select(estimate = 4)
} else if(attributes(df)$model_specifications$test == "Chi-sqr") {
dat = df %>%
select(estimate = 2)
}
if(attributes(df)$model_specifications$test == "Chi-sqr"){
stop("This function has not yet a plotting option for the Chi-square test.
You can use the output of 'run_simulation()' to make your own graphs")
}
# Get mean and sd of the test-statistic
meanstat <- mean(dat$estimate)
sdstat   <- sd(dat$estimate)
# Get reference data from meta data of input file
# either zero (when input data is for null-hypothesis test) or
# the difference in regression slopes in the model fitted on the original data
ref <- attributes(df)$test_stat
# calculate probability of finding the reference slope or less/more
# from fitted normal distribution
if (ref < meanstat){
my_prob <- pnorm(ref, mean = meanstat, sd = sdstat, lower.tail = T)
} else {
my_prob <- pnorm(ref, mean = meanstat, sd = sdstat, lower.tail = F)
}
# calculating probabilities
if (ref < meanstat){
my_prob2 <- dat %>%
filter(estimate <= ref) %>%
summarise(n()/nrow(dat)) %>%
as.numeric()
} else {
my_prob2 <- dat %>%
filter(estimate >= ref) %>%
summarise(n()/nrow(dat)) %>%
as.numeric()
}
# Number of bins
nr_reps <- attributes(df)$resampling_specifications$reps
# x-axis title
xtitle = attributes(df)$model_specifications$test
# Creating the histogram and adding a normal distribution
suppressMessages(
p <- ggplot(dat, aes(estimate)) +
geom_histogram(aes(y = ..density..),
fill = "#EFC000FF",
color = "white",
alpha = 0.5,
bins = round(sqrt(nr_reps), 0)) +
stat_function(fun = dnorm,
args = list(mean = meanstat,
sd   = sdstat),
color = '#868686FF',
lwd = 1) +
ylab("density") +
xlab(xtitle) +
theme_bw() +
theme(axis.title.x = element_text(size=13, color = "#EFC000FF"),
axis.text.x  = element_text(size=13, color = "#EFC000FF"),
axis.title.y = element_text(size=13, color = "#EFC000FF"),
axis.text.y  = element_text(size=13, color = "#EFC000FF"))
)
# Creating probability area below curve
# If the reference value is outside the data range of the calculated normal
# curve, this is ignored
suppressMessages(
if(ref >= min(ggplot_build(p)$data[[2]]$x) & ref <= max(ggplot_build(p)$data[[2]]$x)){
if (ref < meanstat){
p <- p +
ggplot_build(p)$data[[2]] %>%
filter(x <= ref) %>%
geom_area(data = ., aes(x = x, y = y),
fill = "#868686FF",
alpha = 0.5)
} else {
p <- p +
ggplot_build(p)$data[[2]] %>%
filter(x >= ref) %>%
geom_area(data = ., aes(x = x, y = y),
fill = "#868686FF",
alpha = 0.5)
}
}
)
if(ref_val != "none"){
suppressMessages(
p <- p +
geom_vline(aes(xintercept = ref_val),
color = "black",
linetype = "dashed")
)
}
# Position for plotting the p-value inside the graph
suppressMessages(
xpos <-0.95*max(ggplot_build(p)$data[[2]]$x)
)
suppressMessages(
ypos <- 0.95 * max(ggplot_build(p)$data[[1]]$y,
ggplot_build(p)$data[[2]]$y)
)
# Adding label with probability and some layout
suppressMessages(
p <- p +
theme(panel.border = element_rect(colour = "#EFC000FF", size = 1.5),
axis.ticks = element_blank()) +
annotate("text", xpos, ypos,
label = paste(100*round(my_prob,3), "%"),
hjust = "inward", vjust = "inward",
fontface = "plain", size = 4.5, color = "#868686FF") +
annotate("text", xpos, ypos*0.9,
label = paste(100*round(my_prob2,3), "%"),
hjust = "inward", vjust = "inward",
fontface = "plain", size = 4.5, color = "#EFC000FF")
)
return(p)
}
require(readr)
require(purrr)
require(tidyr)
require(tidyselect)
require(tidyverse)
require(ggplot2)
require(patchwork)
require(cowplot)
require(PupillometryR)
require(janitor)
require(ggpubr)
require(stringr)
require(broom)
require(rsample)
require(janitor)
library(smesp)
