#' This function visualizes the result of a single simulation, plotting the original
#' data and the simulated data in one single graph. Data and the simulation settings
#' are taken from the data frame + meta data that is generated by the function
#' 'specify_simulation()'. In this function, a few choices need to be made with regard
#' to the sampling procedure.
#' @original_data input data: output of any of the 'specify_simulation()' functions
#' @ref_val Any value you want to compare with the distribution of the
#' test-statistic.This simply plots a vertical line at that value. If you don't
#' want to add this line, chose "none" (default)
#' @x_distr Option "as_data' or 'uniform'. The option 'as_data' generates a
#' density curve on the x-values, with densities used as sample weight for all
#' x-values along the observed x-range. This generates distributions of x-values
#' similar to the observed x-value. The option 'uniform' result in a sampling of
#' x-values from a uniform distribution.
#' @sample_size A number that gives the number of data points generated in the
#' simulation. The option 'as_data' returns the same number as in the original
#' data. The latter is default.
#' @import ggplot2
#' @import dplyr
#' @export
visualise_simulation <- function(
  original_data     = mydf,
  x_distr           = "as_data",
  ref_val           = NULL,
  sample_size       = "as_data")
{
  # Use randomly one of these colors in the graphs
  kleur <- sample(c('#FFA700', '#FFBD40', '#218359', '#235D79', '#034769',
                    "#588C7E", "#F2AE72", "#D96459", "#00AFBB",
                    "#E7B800", "#FC4E07", "#999999", "#E69F00",
                    "#56B4E9", "#009E73", "#F0E442", "#0072B2",
                    "#D55E00", "#CC79A7", "#FFDB6D", "#C4961A", "#00AFBB"), 1)

#---regression slope------------------------------------------------------------
  if(attributes(original_data)$test == "regression slope"){

    # original data
    df <- original_data %>%
      rename(x_obs    = attributes(.)$predictor_variable,
             y_obs    = attributes(.)$response_variable) %>%
      mutate(y_pred   = predict(lm(y_obs ~ x_obs, data = .)),
             orig_res = y_pred-y_obs)

    # getting regression statistics of original data
    coeff_original <- coefficients(lm(y_obs ~ x_obs, data = df))

    # null hypothesis or confidence interval
    if(attributes(df)$procedure == "null-hypothesis"){
      coeff_original[2] <- 0
    } else {
      coeff_original[2] <- coeff_original[2]
      }


    sd_orig_res <- df %>% summarise(tmp = sd(orig_res)) %>% as.numeric()

    if(sample_size == "as_data"){nr_data_points = nrow(df)} else {nr_data_points = sample_size}

    # Getting predictor values and associated error terms
    if(x_distr == "uniform"){
      xy_data <- data.frame(sim_x    = seq(min(df$x_obs), max(df$x_obs),
                                           length.out = max(1024, nr_data_points)),
                            heterosc = seq(1, attributes(df)$heterosc_cont_1,
                                          length.out = max(1024, nr_data_points))) %>%
        mutate(sdx = heterosc * (attributes(df)$error_cont_1 * sd_orig_res) / mean(heterosc)) %>%
        slice_sample(n=nr_data_points, replace=T) %>% select(-heterosc)

    } else if(x_distr == "as_data") {
      tmp <- data.frame(heterosc = seq(1, attributes(df)$heterosc_cont_1, length.out = nr_data_points)) %>%
        mutate(sim_x = seq(min(df$x_obs), max(df$x_obs), length.out = nr_data_points),
               sdx   = heterosc * (attributes(df)$error_cont_1 * sd_orig_res) / mean(heterosc)) %>%
        lm(sdx ~ sim_x, data = .) %>%
        coefficients(.)

      dens_distr_x <-density(df$x_obs, n = max(1024, nr_data_points))

      xy_data <- data.frame(sim_x = sample(dens_distr_x[[1]], nr_data_points,prob = dens_distr_x[[2]], replace=T)) %>%
        mutate(sdx = tmp[1] + tmp[2]*sim_x)

      } else {stop("x_distr has to be 'as_data' or 'uniform")
    }

    xy_data <- xy_data %>%
      mutate(y_pop    = coeff_original[1] + coeff_original[2] * sim_x,
             residual = rnorm(nr_data_points, 0, sdx),
             sim_y    = y_pop + residual) %>%
      select(-y_pop, -residual) %>%
      mutate(sim_pred = predict(lm(sim_y ~ sim_x, data = .)))



    p1 <- ggplot() +
      geom_line(data = df,aes(x_obs, y_pred),
                color    = "lightgrey", alpha = 0.5, size = 0.8) +
      geom_line(data = xy_data, aes(sim_x, sim_pred),
                color = kleur, size = 1.3, alpha = 0.7) +
      geom_point(data = xy_data, aes(sim_x, sim_y),
                 shape    = 21, fill     = kleur, color = kleur, size = 4, alpha = 0.4)+
      geom_point(data = df,aes(x_obs, y_obs),
                 shape = 1,color = "lightgrey", alpha = 0.7, size = 4)+
      labs(y = attributes(df)$response_variable, x = attributes(df)$predictor_variable) +
      theme_bw()

    return(p1)

#---difference between regression slopes----------------------------------------
  } else if(attributes(original_data)$test == "difference between regression slopes"){

    # original data
    df <- original_data %>%
      rename(x_cont   = attributes(.)$continuous_predictor,
             x_cat    = attributes(.)$categorical_predictor,
             y_obs    = attributes(.)$response_variable) %>%
      mutate(y_pred   = predict(lm(y_obs ~ x_cont*x_cat, data = .)),
             orig_res = y_pred-y_obs)

    sd_orig_res <- df %>% summarise(tmp = sd(orig_res)) %>% as.numeric()

    if(sample_size == "as_data"){nr_data_points = nrow(df)} else {nr_data_points = sample_size}

    # Getting predictor values and associated error terms
    if(x_distr == "uniform"){
      xy_data <- data.frame(sim_x    = seq(min(df$x_obs), max(df$x_obs),
                                           length.out = max(1024, nr_data_points)),
                            heterosc = seq(1, attributes(df)$heterosc_cont_1,
                                           length.out = max(1024, nr_data_points))) %>%
        mutate(sdx = heterosc * (attributes(df)$error_cont_1 * sd_orig_res) / mean(heterosc)) %>%
        slice_sample(n=nr_data_points, replace=T) %>% select(-heterosc)

    } else if(x_distr == "as_data") {
      tmp <- data.frame(heterosc = seq(1, attributes(df)$heterosc_cont_1, length.out = nr_data_points)) %>%
        mutate(sim_x = seq(min(df$x_obs), max(df$x_obs), length.out = nr_data_points),
               sdx   = heterosc * (attributes(df)$error_cont_1 * sd_orig_res) / mean(heterosc)) %>%
        lm(sdx ~ sim_x, data = .) %>%
        coefficients(.)

      dens_distr_x <-density(df$x_obs, n = max(1024, nr_data_points))

      xy_data <- data.frame(sim_x = sample(dens_distr_x[[1]], nr_data_points,prob = dens_distr_x[[2]], replace=T)) %>%
        mutate(sdx = tmp[1] + tmp[2]*sim_x)

    } else {stop("x_distr has to be 'as_data' or 'uniform")
    }

    # When null hypothesis: regression statistics of the model fitted on original
    # data without the categorical variable (i.e., no difference in intercept and slope)
    if(attributes(df)$procedure == "null-hypothesis"){
      coeff_original  <- coefficients(lm(y_obs ~ x_cont, data = df))
    } else {
      # When confidence interval: regression statistics of the model fitted on
      # original data with the categorical variable
      coeff_original  <- coefficients(lm(y_obs ~ x_cont*x_cat, data = df))
    }

    xy_data <- xy_data %>%
      mutate(y_pop    = coeff_original[1] + coeff_original[2] * sim_x,
             residual = rnorm(nr_data_points, 0, sdx),
             sim_y    = y_pop + residual) %>%
      select(-y_pop, -residual) %>%
      mutate(sim_pred = predict(lm(sim_y ~ sim_x, data = .)))



    p1 <- ggplot() +
      geom_line(data = df,aes(x_obs, y_pred),
                color    = "lightgrey", alpha = 0.5, size = 0.8) +
      geom_line(data = xy_data, aes(sim_x, sim_pred),
                color = kleur, size = 1.3, alpha = 0.7) +
      geom_point(data = xy_data, aes(sim_x, sim_y),
                 shape    = 21, fill     = kleur, color = kleur, size = 4, alpha = 0.4)+
      geom_point(data = df,aes(x_obs, y_obs),
                 shape = 1,color = "lightgrey", alpha = 0.7, size = 4)+
      labs(y = attributes(df)$response_variable, x = attributes(df)$predictor_variable) +
      theme_bw()

    return(p1)
  }
}

